%if False

> {-# LANGUAGE GADTs, PolyKinds, KindSignatures, MultiParamTypeClasses,
>     DataKinds, FlexibleInstances, RankNTypes, FlexibleContexts #-}

> module NATTYInNatty where

%endif

Eisenberg and Weirich's \singletons library~\cite{singletons}
automatically generates equivalents of the |Natty| data type and
|NATTY| type class from the |Nat| data type.

< data Nat = Z | S Nat
< 
< $(genSingletons [PRIMEPRIME Nat])
< 
< type Natty = SNat
< type NATTY = SingRep
< 
< natty :: NATTY n => Natty n
< natty = sing
< 
< natter :: Natty n -> (NATTY n => t) -> t
< natter n b = case singInstance n of SingInstance -> b

%$

There is one material difference between our hand-coded version and
the singleton data type generated by the \singletons
library. Modulo inessential differences, the latter generates the
following data type:

< data SNat :: Nat -> * where
<   SZ :: SNat Z
<   SS :: NATTY n => SNat n -> SNat (S n)

Unlike our original version, the generated singleton has a |NATTY|
constraint on the |SS| constructor.

A disadvantage of this design choice is that it sometimes requires
|NATTY| constraints to be brought into scope explicitly using
|natter|. For instance, without the |NATTY| constraint on |SS|, we can
write the vector length function directly as follows:

< vlength :: Vec n x -> Natty n
< vlength V0        = SZ
< vlength (x :> xs) = vlength (x :> xs) = SS (vlength xs)

But with the |NATTY| constraint on |SS|, we must write:

< vlength :: Vec n x -> Natty n
< vlength V0        = SZ
< vlength (x :> xs) = natter n (SS n) where n = vlength xs

in order to bring the appropriate |NATTY| constraint into scope for
the inductive case.

[Come up with an example where the |NATTY| constraint is helpful.]

